"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typeit-react";
exports.ids = ["vendor-chunks/typeit-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/typeit-react/dist/index.es.js":
/*!****************************************************!*\
  !*** ./node_modules/typeit-react/dist/index.es.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypeIt)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _TypeIt_instances, empty_fn, fire_fn, move_fn, prepLoop_fn, fireItemWithContext_fn, wait_fn, attachCursor_fn, elementIsInput_fn, queueAndReturn_fn, maybeAppendPause_fn, generateTemporaryOptionQueueItems_fn, updateOptions_fn, generateQueue_fn, _buildOptions, prependHardcodedStrings_fn, setUpCursor_fn, addSplitPause_fn, type_fn, delete_fn, removeNode_fn, getPace_fn, derivedCursorPosition_get, isInput_get, shouldRenderCursor_get, allChars_get, _a;\n\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => isArray(value) ? value : [value];\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      var _a2;\n      return _q.set(Symbol((_a2 = step.char) == null ? void 0 : _a2.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    done,\n    reset,\n    destroy,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nconst createElement = (el) => document.createElement(el);\nconst createTextNode = (content) => document.createTextNode(content);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst toArray = (val) => Array.from(val);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      var _a2, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a2 = node.classList) == null ? void 0 : _a2.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst cleanUpSkipped = ({\n  index,\n  newIndex,\n  queueItems,\n  cleanUp\n}) => {\n  for (let i = index + 1; i < newIndex + 1; i++) {\n    cleanUp(queueItems[i][0]);\n  }\n};\nconst isNumber = (value) => Number.isInteger(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element == null ? void 0 : element.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions) return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => {\n  var _a2;\n  return (_a2 = queueItem.func) == null ? void 0 : _a2.call(null);\n};\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => {\n  return \"value\" in el;\n};\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : (\n    // If we add one-off fresh elements, there will be no\n    // \"originalParent\", so always fall back to the default target.\n    character.originalParent || originalTarget\n  );\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nlet processCursorOptions = (cursorOptions) => {\n  var _a2, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a2 = cursorOptions.animation) == null ? void 0 : _a2.frames) || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst removeNode = (node, rootElement) => {\n  if (!node) return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? (\n    // This parent still needs to exist.\n    node\n  ) : (\n    // There's nothing else in there, so just delete the entire thing.\n    // By doing this, we clean up markup as we go along.\n    nodeParent\n  );\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nfunction splitOnBreak(str) {\n  return str.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n}\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet TypeIt$1 = (_a = class {\n  constructor(element, options = {}) {\n    __privateAdd(this, _TypeIt_instances);\n    __publicField(this, \"element\");\n    __publicField(this, \"timeouts\");\n    __publicField(this, \"cursorPosition\");\n    __publicField(this, \"predictedCursorPosition\");\n    __publicField(this, \"statuses\", {\n      started: false,\n      completed: false,\n      frozen: false,\n      destroyed: false\n    });\n    __publicField(this, \"opts\");\n    __publicField(this, \"id\");\n    __publicField(this, \"queue\");\n    __publicField(this, \"cursor\");\n    __publicField(this, \"unfreeze\", () => {\n    });\n    __publicField(this, \"is\", function(key) {\n      return this.statuses[key];\n    });\n    __privateAdd(this, _buildOptions, (options) => {\n      options.cursor = processCursorOptions(\n        options.cursor ?? DEFAULT_OPTIONS.cursor\n      );\n      this.opts.strings = __privateMethod(this, _TypeIt_instances, prependHardcodedStrings_fn).call(this, asArray(this.opts.strings));\n      this.opts = merge(this.opts, {\n        html: !__privateGet(this, _TypeIt_instances, isInput_get) && this.opts.html,\n        nextStringDelay: calculateDelay(this.opts.nextStringDelay),\n        loopDelay: calculateDelay(this.opts.loopDelay)\n      });\n    });\n    this.opts = merge(DEFAULT_OPTIONS, options);\n    this.element = selectorToElement(element);\n    this.timeouts = [];\n    this.cursorPosition = 0;\n    this.unfreeze = () => {\n    };\n    this.predictedCursorPosition = null;\n    this.statuses = merge({}, DEFAULT_STATUSES);\n    this.id = generateHash();\n    this.queue = Queue([{ delay: this.opts.startDelay }]);\n    __privateGet(this, _buildOptions).call(this, options);\n    this.cursor = __privateMethod(this, _TypeIt_instances, setUpCursor_fn).call(this);\n    this.element.dataset.typeitId = this.id;\n    appendStyleBlock(PLACEHOLDER_CSS);\n    if (this.opts.strings.length) {\n      __privateMethod(this, _TypeIt_instances, generateQueue_fn).call(this);\n    }\n  }\n  /**\n   * Can only be called once.\n   */\n  go() {\n    if (this.statuses.started) {\n      return this;\n    }\n    __privateMethod(this, _TypeIt_instances, attachCursor_fn).call(this);\n    if (!this.opts.waitUntilVisible) {\n      __privateMethod(this, _TypeIt_instances, fire_fn).call(this);\n      return this;\n    }\n    fireWhenVisible(this.element, __privateMethod(this, _TypeIt_instances, fire_fn).bind(this));\n    return this;\n  }\n  destroy(shouldRemoveCursor = true) {\n    this.timeouts = destroyTimeouts(this.timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && this.cursor && __privateMethod(this, _TypeIt_instances, removeNode_fn).call(this, this.cursor);\n    this.statuses.destroyed = true;\n  }\n  reset(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      this.queue.wipe();\n      rebuild(this);\n    } else {\n      this.queue.reset();\n    }\n    this.cursorPosition = 0;\n    for (let property in this.statuses) {\n      this.statuses[property] = false;\n    }\n    this.element[__privateMethod(this, _TypeIt_instances, elementIsInput_fn).call(this) ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  }\n  type(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = __privateMethod(this, _TypeIt_instances, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let chars = maybeChunkStringAsHtml(string, this.opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => __privateMethod(this, _TypeIt_instances, type_fn).call(this, char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : __privateMethod(this, _TypeIt_instances, getPace_fn).call(this),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await this.opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await this.opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, itemsToQueue, actionOpts);\n  }\n  break(actionOpts = {}) {\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, {\n      func: () => __privateMethod(this, _TypeIt_instances, type_fn).call(this, createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  }\n  move(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = __privateMethod(this, _TypeIt_instances, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: this.queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: __privateGet(this, _TypeIt_instances, derivedCursorPosition_get)\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    this.predictedCursorPosition = __privateGet(this, _TypeIt_instances, derivedCursorPosition_get) + numberOfSteps;\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: () => __privateMethod(this, _TypeIt_instances, move_fn).call(this, directionalStep),\n          delay: instant ? 0 : __privateMethod(this, _TypeIt_instances, getPace_fn).call(this),\n          cursorable: true\n        },\n        Math.abs(numberOfSteps)\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  exec(func, actionOpts = {}) {\n    let bookEndQueueItems = __privateMethod(this, _TypeIt_instances, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]], actionOpts);\n  }\n  options(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    __privateMethod(this, _TypeIt_instances, updateOptions_fn).call(this, opts);\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, {}, actionOpts);\n  }\n  pause(milliseconds, actionOpts = {}) {\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, { delay: handleFunctionalArg(milliseconds) }, actionOpts);\n  }\n  delete(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = __privateMethod(this, _TypeIt_instances, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = this.queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: __privateGet(this, _TypeIt_instances, derivedCursorPosition_get),\n        to\n      });\n    })();\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: __privateMethod(this, _TypeIt_instances, delete_fn).bind(this),\n          delay: instant ? 0 : __privateMethod(this, _TypeIt_instances, getPace_fn).call(this, 1),\n          deletable: true\n        },\n        rounds\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  freeze() {\n    this.statuses.frozen = true;\n  }\n  /**\n   * Like `.go()`, but more... \"off the grid.\"\n   *\n   * - won't trigger `afterComplete` callback\n   * - items won't be replayed after `.reset()`\n   *\n   * When called, all non-done items will be \"flushed\" --\n   * that is, executed, but not remembered.\n   */\n  flush(cb = () => {\n  }) {\n    __privateMethod(this, _TypeIt_instances, attachCursor_fn).call(this);\n    __privateMethod(this, _TypeIt_instances, fire_fn).call(this, false).then(cb);\n    return this;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getOptions() {\n    return this.opts;\n  }\n  updateOptions(options) {\n    return __privateMethod(this, _TypeIt_instances, updateOptions_fn).call(this, options);\n  }\n  getElement() {\n    return this.element;\n  }\n  empty(actionOpts = {}) {\n    return __privateMethod(this, _TypeIt_instances, queueAndReturn_fn).call(this, { func: __privateMethod(this, _TypeIt_instances, empty_fn).bind(this) }, actionOpts);\n  }\n}, _TypeIt_instances = new WeakSet(), empty_fn = async function() {\n  if (__privateMethod(this, _TypeIt_instances, elementIsInput_fn).call(this)) {\n    this.element.value = \"\";\n    return;\n  }\n  __privateGet(this, _TypeIt_instances, allChars_get).forEach(__privateMethod(this, _TypeIt_instances, removeNode_fn).bind(this));\n  return;\n}, fire_fn = async function(remember = true) {\n  this.statuses.started = true;\n  let cleanUp = (qKey) => {\n    this.queue.done(qKey, !remember);\n  };\n  try {\n    let queueItems = [...this.queue.getQueue()];\n    for (let index = 0; index < queueItems.length; index++) {\n      let [queueKey, queueItem] = queueItems[index];\n      if (queueItem.done) continue;\n      if (!queueItem.deletable || queueItem.deletable && __privateGet(this, _TypeIt_instances, allChars_get).length) {\n        let newIndex = await __privateMethod(this, _TypeIt_instances, fireItemWithContext_fn).call(this, index, queueItems);\n        cleanUpSkipped({\n          index,\n          newIndex,\n          queueItems,\n          cleanUp\n        });\n        index = newIndex;\n      }\n      cleanUp(queueKey);\n    }\n    if (!remember) {\n      return this;\n    }\n    this.statuses.completed = true;\n    await this.opts.afterComplete(this);\n    if (!this.opts.loop) {\n      throw \"\";\n    }\n    let delay = this.opts.loopDelay;\n    __privateMethod(this, _TypeIt_instances, wait_fn).call(this, async () => {\n      await __privateMethod(this, _TypeIt_instances, prepLoop_fn).call(this, delay[0]);\n      __privateMethod(this, _TypeIt_instances, fire_fn).call(this);\n    }, delay[1]);\n  } catch (e) {\n  }\n  return this;\n}, move_fn = async function(step) {\n  this.cursorPosition = updateCursorPosition(\n    step,\n    this.cursorPosition,\n    __privateGet(this, _TypeIt_instances, allChars_get)\n  );\n  repositionCursor(this.element, __privateGet(this, _TypeIt_instances, allChars_get), this.cursorPosition);\n}, prepLoop_fn = async function(delay) {\n  let derivedCursorPosition = __privateGet(this, _TypeIt_instances, derivedCursorPosition_get);\n  derivedCursorPosition && await __privateMethod(this, _TypeIt_instances, move_fn).call(this, { value: derivedCursorPosition });\n  let queueItems = __privateGet(this, _TypeIt_instances, allChars_get).map((c) => {\n    return [\n      Symbol(),\n      {\n        func: __privateMethod(this, _TypeIt_instances, delete_fn).bind(this),\n        delay: __privateMethod(this, _TypeIt_instances, getPace_fn).call(this, 1),\n        deletable: true,\n        shouldPauseCursor: () => true\n      }\n    ];\n  });\n  for (let index = 0; index < queueItems.length; index++) {\n    await __privateMethod(this, _TypeIt_instances, fireItemWithContext_fn).call(this, index, queueItems);\n  }\n  this.queue.reset();\n  this.queue.set(0, { delay });\n}, fireItemWithContext_fn = function(index, queueItems) {\n  return fireItem({\n    index,\n    queueItems,\n    wait: __privateMethod(this, _TypeIt_instances, wait_fn).bind(this),\n    cursor: this.cursor,\n    cursorOptions: this.opts.cursor\n  });\n}, wait_fn = async function(callback, delay, silent = false) {\n  if (this.statuses.frozen) {\n    await new Promise((resolve) => {\n      this.unfreeze = () => {\n        this.statuses.frozen = false;\n        resolve();\n      };\n    });\n  }\n  silent || await this.opts.beforeStep(this);\n  await wait(callback, delay, this.timeouts);\n  silent || await this.opts.afterStep(this);\n}, attachCursor_fn = async function() {\n  !__privateMethod(this, _TypeIt_instances, elementIsInput_fn).call(this) && this.cursor && this.element.appendChild(this.cursor);\n  if (__privateGet(this, _TypeIt_instances, shouldRenderCursor_get)) {\n    setCursorStyles(this.id, this.element);\n    this.cursor.dataset.tiAnimationId = this.id;\n    let { animation } = this.opts.cursor;\n    let { frames, options } = animation;\n    setCursorAnimation({\n      frames,\n      cursor: this.cursor,\n      options: {\n        duration: this.opts.cursorSpeed,\n        ...options\n      }\n    });\n  }\n}, elementIsInput_fn = function() {\n  return isInput(this.element);\n}, queueAndReturn_fn = function(steps, opts) {\n  this.queue.add(steps);\n  __privateMethod(this, _TypeIt_instances, maybeAppendPause_fn).call(this, opts);\n  return this;\n}, maybeAppendPause_fn = function(opts = {}) {\n  let delay = opts.delay;\n  delay && this.queue.add({ delay });\n}, generateTemporaryOptionQueueItems_fn = function(newOptions = {}) {\n  return [\n    { func: () => __privateMethod(this, _TypeIt_instances, updateOptions_fn).call(this, newOptions) },\n    { func: () => __privateMethod(this, _TypeIt_instances, updateOptions_fn).call(this, this.opts) }\n  ];\n}, updateOptions_fn = async function(opts) {\n  this.opts = merge(this.opts, opts);\n}, /**\n * Based on provided strings, generate a TypeIt queue\n * to be fired for each character in the string.\n */\ngenerateQueue_fn = function() {\n  let strings = this.opts.strings.filter((string) => !!string);\n  strings.forEach((string, index) => {\n    this.type(string);\n    if (index + 1 === strings.length) {\n      return;\n    }\n    let splitItems = this.opts.breakLines ? [{ func: () => __privateMethod(this, _TypeIt_instances, type_fn).call(this, createElement(\"BR\")), typeable: true }] : duplicate(\n      {\n        func: __privateMethod(this, _TypeIt_instances, delete_fn).bind(this),\n        delay: __privateMethod(this, _TypeIt_instances, getPace_fn).call(this, 1)\n      },\n      this.queue.getTypeable().length\n    );\n    __privateMethod(this, _TypeIt_instances, addSplitPause_fn).call(this, splitItems);\n  });\n}, _buildOptions = new WeakMap(), prependHardcodedStrings_fn = function(strings) {\n  let existingMarkup = this.element.innerHTML;\n  if (!existingMarkup) {\n    return strings;\n  }\n  this.element.innerHTML = \"\";\n  if (this.opts.startDelete) {\n    this.element.innerHTML = existingMarkup;\n    expandTextNodes(this.element);\n    __privateMethod(this, _TypeIt_instances, addSplitPause_fn).call(this, duplicate(\n      {\n        func: __privateMethod(this, _TypeIt_instances, delete_fn).bind(this),\n        delay: __privateMethod(this, _TypeIt_instances, getPace_fn).call(this, 1),\n        deletable: true\n      },\n      __privateGet(this, _TypeIt_instances, allChars_get).length\n    ));\n    return strings;\n  }\n  return splitOnBreak(existingMarkup).concat(strings);\n}, /**\n * Provided it's a non-form element and the options is provided,\n * set up the cursor element for the animation.\n */\nsetUpCursor_fn = function() {\n  if (__privateGet(this, _TypeIt_instances, isInput_get)) {\n    return null;\n  }\n  let cursor = createElement(\"span\");\n  cursor.className = CURSOR_CLASS;\n  if (!__privateGet(this, _TypeIt_instances, shouldRenderCursor_get)) {\n    cursor.style.visibility = \"hidden\";\n    return cursor;\n  }\n  cursor.innerHTML = getParsedBody(this.opts.cursorChar).innerHTML;\n  return cursor;\n}, addSplitPause_fn = function(items) {\n  let delay = this.opts.nextStringDelay;\n  this.queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n}, type_fn = function(char) {\n  insertIntoElement(this.element, char);\n}, delete_fn = function() {\n  if (!__privateGet(this, _TypeIt_instances, allChars_get).length) return;\n  if (__privateGet(this, _TypeIt_instances, isInput_get)) {\n    this.element.value = this.element.value.slice(0, -1);\n  } else {\n    __privateMethod(this, _TypeIt_instances, removeNode_fn).call(this, __privateGet(this, _TypeIt_instances, allChars_get)[this.cursorPosition]);\n  }\n}, removeNode_fn = function(node) {\n  removeNode(node, this.element);\n}, getPace_fn = function(index = 0) {\n  return calculatePace(this.opts)[index];\n}, derivedCursorPosition_get = function() {\n  return this.predictedCursorPosition ?? this.cursorPosition;\n}, isInput_get = function() {\n  return isInput(this.element);\n}, shouldRenderCursor_get = function() {\n  return !!this.opts.cursor && !__privateGet(this, _TypeIt_instances, isInput_get);\n}, allChars_get = function() {\n  return getAllChars(this.element);\n}, _a);\nconst DynamicElementComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const { as: As } = props;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(As, { ref, ...props });\n});\nconst defaultPropOptions = {};\nconst TypeIt = ({\n  as = \"span\",\n  options = defaultPropOptions,\n  children = null,\n  getBeforeInit = (instance) => instance,\n  getAfterInit = (instance) => instance,\n  ...remainingProps\n}) => {\n  const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const instanceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [shouldShowChildren, setShouldShowChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n  const [instanceOptions, setInstanceOptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a2;\n    if (!instanceOptions) return;\n    ((_a2 = instanceRef.current) == null ? void 0 : _a2.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => {\n      var _a2;\n      return (_a2 = instanceRef.current) == null ? void 0 : _a2.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\n    DynamicElementComponent,\n    {\n      ref: elementRef,\n      as,\n      children: shouldShowChildren ? children : null,\n      style: { opacity: shouldShowChildren ? 0 : 1 },\n      ...remainingProps\n    }\n  );\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZWl0LXJlYWN0L2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsU0FBUztBQUMxRyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLFVBQVUsY0FBYyx1QkFBdUIsVUFBVSxvQkFBb0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixpQkFBaUIsY0FBYyxpQkFBaUI7QUFDcEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNELGdDQUFnQyxpREFBVTtBQUMxQyxVQUFVLFNBQVM7QUFDbkIseUJBQXlCLDBEQUFtQixPQUFPLGVBQWU7QUFDbEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCLDZDQUFNO0FBQzNCLHNCQUFzQiw2Q0FBTTtBQUM1QixzREFBc0QsK0NBQVE7QUFDOUQsZ0RBQWdELCtDQUFRO0FBQ3hEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsMERBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLW5ldy8uL25vZGVfbW9kdWxlcy90eXBlaXQtcmVhY3QvZGlzdC9pbmRleC5lcy5qcz85YWM5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4gKF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwiYWNjZXNzIHByaXZhdGUgbWV0aG9kXCIpLCBtZXRob2QpO1xudmFyIF9UeXBlSXRfaW5zdGFuY2VzLCBlbXB0eV9mbiwgZmlyZV9mbiwgbW92ZV9mbiwgcHJlcExvb3BfZm4sIGZpcmVJdGVtV2l0aENvbnRleHRfZm4sIHdhaXRfZm4sIGF0dGFjaEN1cnNvcl9mbiwgZWxlbWVudElzSW5wdXRfZm4sIHF1ZXVlQW5kUmV0dXJuX2ZuLCBtYXliZUFwcGVuZFBhdXNlX2ZuLCBnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXNfZm4sIHVwZGF0ZU9wdGlvbnNfZm4sIGdlbmVyYXRlUXVldWVfZm4sIF9idWlsZE9wdGlvbnMsIHByZXBlbmRIYXJkY29kZWRTdHJpbmdzX2ZuLCBzZXRVcEN1cnNvcl9mbiwgYWRkU3BsaXRQYXVzZV9mbiwgdHlwZV9mbiwgZGVsZXRlX2ZuLCByZW1vdmVOb2RlX2ZuLCBnZXRQYWNlX2ZuLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0LCBpc0lucHV0X2dldCwgc2hvdWxkUmVuZGVyQ3Vyc29yX2dldCwgYWxsQ2hhcnNfZ2V0LCBfYTtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGlzQXJyYXkgPSAodGhpbmcpID0+IEFycmF5LmlzQXJyYXkodGhpbmcpO1xuY29uc3QgYXNBcnJheSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5sZXQgUXVldWUgPSBmdW5jdGlvbihpbml0aWFsSXRlbXMpIHtcbiAgbGV0IGFkZCA9IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgYXNBcnJheShzdGVwcykuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiBfcS5zZXQoU3ltYm9sKChfYTIgPSBzdGVwLmNoYXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaW5uZXJUZXh0KSwgYnVpbGRRdWV1ZUl0ZW0oeyAuLi5zdGVwIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgbGV0IGdldFR5cGVhYmxlID0gKCkgPT4gcmF3VmFsdWVzKCkuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUudHlwZWFibGUpO1xuICBsZXQgc2V0ID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICBsZXQga2V5cyA9IFsuLi5fcS5rZXlzKCldO1xuICAgIF9xLnNldChrZXlzW2luZGV4XSwgYnVpbGRRdWV1ZUl0ZW0oaXRlbSkpO1xuICB9O1xuICBsZXQgYnVpbGRRdWV1ZUl0ZW0gPSAocXVldWVJdGVtKSA9PiB7XG4gICAgcXVldWVJdGVtLnNob3VsZFBhdXNlQ3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnR5cGVhYmxlIHx8IHRoaXMuY3Vyc29yYWJsZSB8fCB0aGlzLmRlbGV0YWJsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcXVldWVJdGVtO1xuICB9O1xuICBsZXQgcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBfcS5mb3JFYWNoKChpdGVtKSA9PiBkZWxldGUgaXRlbS5kb25lKTtcbiAgfTtcbiAgbGV0IHdpcGUgPSBmdW5jdGlvbigpIHtcbiAgICBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgYWRkKGluaXRpYWxJdGVtcyk7XG4gIH07XG4gIGxldCBnZXRRdWV1ZSA9ICgpID0+IF9xO1xuICBsZXQgcmF3VmFsdWVzID0gKCkgPT4gQXJyYXkuZnJvbShfcS52YWx1ZXMoKSk7XG4gIGxldCBkZXN0cm95ID0gKGtleSkgPT4gX3EuZGVsZXRlKGtleSk7XG4gIGxldCBnZXRJdGVtcyA9IChhbGwgPSBmYWxzZSkgPT4gYWxsID8gcmF3VmFsdWVzKCkgOiByYXdWYWx1ZXMoKS5maWx0ZXIoKGkpID0+ICFpLmRvbmUpO1xuICBsZXQgZG9uZSA9IChrZXksIHNob3VsZERlc3Ryb3kgPSBmYWxzZSkgPT4gc2hvdWxkRGVzdHJveSA/IF9xLmRlbGV0ZShrZXkpIDogX3EuZ2V0KGtleSkuZG9uZSA9IHRydWU7XG4gIGxldCBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGFkZChpbml0aWFsSXRlbXMpO1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgd2lwZSxcbiAgICBkb25lLFxuICAgIHJlc2V0LFxuICAgIGRlc3Ryb3ksXG4gICAgZ2V0SXRlbXMsXG4gICAgZ2V0UXVldWUsXG4gICAgZ2V0VHlwZWFibGVcbiAgfTtcbn07XG5jb25zdCBEQVRBX0FUVFJJQlVURSA9IFwiZGF0YS10eXBlaXQtaWRcIjtcbmNvbnN0IENVUlNPUl9DTEFTUyA9IFwidGktY3Vyc29yXCI7XG5jb25zdCBFTkQgPSBcIkVORFwiO1xuY29uc3QgREVGQVVMVF9TVEFUVVNFUyA9IHtcbiAgc3RhcnRlZDogZmFsc2UsXG4gIGNvbXBsZXRlZDogZmFsc2UsXG4gIGZyb3plbjogZmFsc2UsXG4gIGRlc3Ryb3llZDogZmFsc2Vcbn07XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGJyZWFrTGluZXM6IHRydWUsXG4gIGN1cnNvcjoge1xuICAgIGF1dG9QYXVzZTogdHJ1ZSxcbiAgICBhdXRvUGF1c2VEZWxheTogNTAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZnJhbWVzOiBbMCwgMCwgMV0ubWFwKChuKSA9PiB7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHk6IG4gfTtcbiAgICAgIH0pLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBpdGVyYXRpb25zOiBJbmZpbml0eSxcbiAgICAgICAgZWFzaW5nOiBcInN0ZXBzKDIsIHN0YXJ0KVwiLFxuICAgICAgICBmaWxsOiBcImZvcndhcmRzXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGN1cnNvckNoYXI6IFwifFwiLFxuICBjdXJzb3JTcGVlZDogMWUzLFxuICBkZWxldGVTcGVlZDogbnVsbCxcbiAgaHRtbDogdHJ1ZSxcbiAgbGlmZUxpa2U6IHRydWUsXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wRGVsYXk6IDc1MCxcbiAgbmV4dFN0cmluZ0RlbGF5OiA3NTAsXG4gIHNwZWVkOiAxMDAsXG4gIHN0YXJ0RGVsYXk6IDI1MCxcbiAgc3RhcnREZWxldGU6IGZhbHNlLFxuICBzdHJpbmdzOiBbXSxcbiAgd2FpdFVudGlsVmlzaWJsZTogZmFsc2UsXG4gIGJlZm9yZVN0cmluZzogKCkgPT4ge1xuICB9LFxuICBhZnRlclN0cmluZzogKCkgPT4ge1xuICB9LFxuICBiZWZvcmVTdGVwOiAoKSA9PiB7XG4gIH0sXG4gIGFmdGVyU3RlcDogKCkgPT4ge1xuICB9LFxuICBhZnRlckNvbXBsZXRlOiAoKSA9PiB7XG4gIH1cbn07XG5jb25zdCBQTEFDRUhPTERFUl9DU1MgPSBgWyR7REFUQV9BVFRSSUJVVEV9XTpiZWZvcmUge2NvbnRlbnQ6ICcuJzsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMDsgdmlzaWJpbGl0eTogaGlkZGVuO31gO1xuY29uc3QgY3JlYXRlRWxlbWVudCA9IChlbCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbCk7XG5jb25zdCBjcmVhdGVUZXh0Tm9kZSA9IChjb250ZW50KSA9PiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KTtcbmNvbnN0IGFwcGVuZFN0eWxlQmxvY2sgPSAoc3R5bGVzLCBpZCA9IFwiXCIpID0+IHtcbiAgbGV0IHN0eWxlQmxvY2sgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlQmxvY2suaWQgPSBpZDtcbiAgc3R5bGVCbG9jay5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUJsb2NrKTtcbn07XG5jb25zdCBjYWxjdWxhdGVEZWxheSA9IChkZWxheUFyZykgPT4ge1xuICBpZiAoIWlzQXJyYXkoZGVsYXlBcmcpKSB7XG4gICAgZGVsYXlBcmcgPSBbZGVsYXlBcmcgLyAyLCBkZWxheUFyZyAvIDJdO1xuICB9XG4gIHJldHVybiBkZWxheUFyZztcbn07XG5jb25zdCByYW5kb21JblJhbmdlID0gKHZhbHVlLCByYW5nZTIpID0+IHtcbiAgcmV0dXJuIE1hdGguYWJzKFxuICAgIE1hdGgucmFuZG9tKCkgKiAodmFsdWUgKyByYW5nZTIgLSAodmFsdWUgLSByYW5nZTIpKSArICh2YWx1ZSAtIHJhbmdlMilcbiAgKTtcbn07XG5sZXQgcmFuZ2UgPSAodmFsKSA9PiB2YWwgLyAyO1xuZnVuY3Rpb24gY2FsY3VsYXRlUGFjZShvcHRpb25zKSB7XG4gIGxldCB7IHNwZWVkLCBkZWxldGVTcGVlZCwgbGlmZUxpa2UgfSA9IG9wdGlvbnM7XG4gIGRlbGV0ZVNwZWVkID0gZGVsZXRlU3BlZWQgIT09IG51bGwgPyBkZWxldGVTcGVlZCA6IHNwZWVkIC8gMztcbiAgcmV0dXJuIGxpZmVMaWtlID8gW1xuICAgIHJhbmRvbUluUmFuZ2Uoc3BlZWQsIHJhbmdlKHNwZWVkKSksXG4gICAgcmFuZG9tSW5SYW5nZShkZWxldGVTcGVlZCwgcmFuZ2UoZGVsZXRlU3BlZWQpKVxuICBdIDogW3NwZWVkLCBkZWxldGVTcGVlZF07XG59XG5jb25zdCB0b0FycmF5ID0gKHZhbCkgPT4gQXJyYXkuZnJvbSh2YWwpO1xubGV0IGV4cGFuZFRleHROb2RlcyA9IChlbGVtZW50KSA9PiB7XG4gIFsuLi5lbGVtZW50LmNoaWxkTm9kZXNdLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgWy4uLmNoaWxkLm5vZGVWYWx1ZV0uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjaGlsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjcmVhdGVUZXh0Tm9kZShjKSwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhwYW5kVGV4dE5vZGVzKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IGdldFBhcnNlZEJvZHkgPSAoY29udGVudCkgPT4ge1xuICBsZXQgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGRvYy5ib2R5LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIHJldHVybiBleHBhbmRUZXh0Tm9kZXMoZG9jLmJvZHkpO1xufTtcbmZ1bmN0aW9uIHdhbGtFbGVtZW50Tm9kZXMoZWxlbWVudCwgc2hvdWxkUmV2ZXJzZSA9IGZhbHNlLCBzaG91bGRJbmNsdWRlQ3Vyc29yID0gZmFsc2UpIHtcbiAgbGV0IGN1cnNvciA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Q1VSU09SX0NMQVNTfWApO1xuICBsZXQgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfQUxMLCB7XG4gICAgYWNjZXB0Tm9kZTogKG5vZGUpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKGN1cnNvciAmJiBzaG91bGRJbmNsdWRlQ3Vyc29yKSB7XG4gICAgICAgIGlmICgoX2EyID0gbm9kZS5jbGFzc0xpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29udGFpbnMoQ1VSU09SX0NMQVNTKSkge1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnNvci5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoKF9iID0gbm9kZS5jbGFzc0xpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250YWlucyhDVVJTT1JfQ0xBU1MpKSA/IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCA6IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG4gIH0pO1xuICBsZXQgbmV4dE5vZGU7XG4gIGxldCBub2RlcyA9IFtdO1xuICB3aGlsZSAobmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgIGlmICghbmV4dE5vZGUub3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgIG5leHROb2RlLm9yaWdpbmFsUGFyZW50ID0gbmV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgbm9kZXMucHVzaChuZXh0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFJldmVyc2UgPyBub2Rlcy5yZXZlcnNlKCkgOiBub2Rlcztcbn1cbmZ1bmN0aW9uIGNodW5rU3RyaW5nQXNIdG1sKHN0cmluZykge1xuICByZXR1cm4gd2Fsa0VsZW1lbnROb2RlcyhnZXRQYXJzZWRCb2R5KHN0cmluZykpO1xufVxuZnVuY3Rpb24gbWF5YmVDaHVua1N0cmluZ0FzSHRtbChzdHIsIGFzSHRtbCA9IHRydWUpIHtcbiAgcmV0dXJuIGFzSHRtbCA/IGNodW5rU3RyaW5nQXNIdG1sKHN0cikgOiB0b0FycmF5KHN0cikubWFwKGNyZWF0ZVRleHROb2RlKTtcbn1cbmNvbnN0IGNsZWFuVXBTa2lwcGVkID0gKHtcbiAgaW5kZXgsXG4gIG5ld0luZGV4LFxuICBxdWV1ZUl0ZW1zLFxuICBjbGVhblVwXG59KSA9PiB7XG4gIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCBuZXdJbmRleCArIDE7IGkrKykge1xuICAgIGNsZWFuVXAocXVldWVJdGVtc1tpXVswXSk7XG4gIH1cbn07XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5jb25zdCBjb3VudFN0ZXBzVG9TZWxlY3RvciA9ICh7XG4gIHF1ZXVlSXRlbXMsXG4gIHNlbGVjdG9yLFxuICBjdXJzb3JQb3NpdGlvbixcbiAgdG9cbn0pID0+IHtcbiAgaWYgKGlzTnVtYmVyKHNlbGVjdG9yKSkge1xuICAgIHJldHVybiBzZWxlY3RvciAqIC0xO1xuICB9XG4gIGxldCBpc01vdmluZ1RvRW5kID0gbmV3IFJlZ0V4cChFTkQsIFwiaVwiKS50ZXN0KHRvKTtcbiAgbGV0IHNlbGVjdG9ySW5kZXggPSBzZWxlY3RvciA/IFsuLi5xdWV1ZUl0ZW1zXS5yZXZlcnNlKCkuZmluZEluZGV4KCh7IGNoYXIgfSkgPT4ge1xuICAgIGxldCBwYXJlbnRFbGVtZW50ID0gY2hhci5wYXJlbnRFbGVtZW50O1xuICAgIGxldCBwYXJlbnRNYXRjaGVzID0gcGFyZW50RWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICBpZiAoaXNNb3ZpbmdUb0VuZCAmJiBwYXJlbnRNYXRjaGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudE1hdGNoZXMgJiYgcGFyZW50RWxlbWVudC5maXJzdENoaWxkLmlzU2FtZU5vZGUoY2hhcik7XG4gIH0pIDogLTE7XG4gIGlmIChzZWxlY3RvckluZGV4IDwgMCkge1xuICAgIHNlbGVjdG9ySW5kZXggPSBpc01vdmluZ1RvRW5kID8gMCA6IHF1ZXVlSXRlbXMubGVuZ3RoIC0gMTtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gaXNNb3ZpbmdUb0VuZCA/IDAgOiAxO1xuICByZXR1cm4gc2VsZWN0b3JJbmRleCAtIGN1cnNvclBvc2l0aW9uICsgb2Zmc2V0O1xufTtcbmNvbnN0IGRlc3Ryb3lUaW1lb3V0cyA9ICh0aW1lb3V0cykgPT4ge1xuICB0aW1lb3V0cy5mb3JFYWNoKGNsZWFyVGltZW91dCk7XG4gIHJldHVybiBbXTtcbn07XG5jb25zdCBkdXBsaWNhdGUgPSAodmFsdWUsIHRpbWVzKSA9PiBuZXcgQXJyYXkodGltZXMpLmZpbGwodmFsdWUpO1xubGV0IGJlZm9yZVBhaW50ID0gKGNiKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhc3luYyAoKSA9PiB7XG4gICAgICByZXNvbHZlKGF3YWl0IGNiKCkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5sZXQgZ2V0QW5pbWF0aW9uRnJvbUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5nZXRBbmltYXRpb25zKCkuZmluZCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGFuaW1hdGlvbi5pZCA9PT0gZWxlbWVudC5kYXRhc2V0LnRpQW5pbWF0aW9uSWQ7XG4gIH0pO1xufTtcbmxldCBzZXRDdXJzb3JBbmltYXRpb24gPSAoe1xuICBjdXJzb3IsXG4gIGZyYW1lcyxcbiAgb3B0aW9uc1xufSkgPT4ge1xuICBsZXQgYW5pbWF0aW9uID0gY3Vyc29yLmFuaW1hdGUoZnJhbWVzLCBvcHRpb25zKTtcbiAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gIGFuaW1hdGlvbi5pZCA9IGN1cnNvci5kYXRhc2V0LnRpQW5pbWF0aW9uSWQ7XG4gIGJlZm9yZVBhaW50KCgpID0+IHtcbiAgICBiZWZvcmVQYWludCgoKSA9PiB7XG4gICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5sZXQgcmVidWlsZEN1cnNvckFuaW1hdGlvbiA9ICh7XG4gIGN1cnNvcixcbiAgb3B0aW9ucyxcbiAgY3Vyc29yT3B0aW9uc1xufSkgPT4ge1xuICBpZiAoIWN1cnNvciB8fCAhY3Vyc29yT3B0aW9ucykgcmV0dXJuO1xuICBsZXQgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uRnJvbUVsZW1lbnQoY3Vyc29yKTtcbiAgbGV0IG9sZEN1cnJlbnRUaW1lO1xuICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgb3B0aW9ucy5kZWxheSA9IGFuaW1hdGlvbi5lZmZlY3QuZ2V0Q29tcHV0ZWRUaW1pbmcoKS5kZWxheTtcbiAgICBvbGRDdXJyZW50VGltZSA9IGFuaW1hdGlvbi5jdXJyZW50VGltZTtcbiAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gIH1cbiAgbGV0IG5ld0FuaW1hdGlvbiA9IHNldEN1cnNvckFuaW1hdGlvbih7XG4gICAgY3Vyc29yLFxuICAgIGZyYW1lczogY3Vyc29yT3B0aW9ucy5hbmltYXRpb24uZnJhbWVzLFxuICAgIG9wdGlvbnNcbiAgfSk7XG4gIGlmIChvbGRDdXJyZW50VGltZSkge1xuICAgIG5ld0FuaW1hdGlvbi5jdXJyZW50VGltZSA9IG9sZEN1cnJlbnRUaW1lO1xuICB9XG4gIHJldHVybiBuZXdBbmltYXRpb247XG59O1xubGV0IGV4ZWN1dGUgPSAocXVldWVJdGVtKSA9PiB7XG4gIHZhciBfYTI7XG4gIHJldHVybiAoX2EyID0gcXVldWVJdGVtLmZ1bmMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2FsbChudWxsKTtcbn07XG5sZXQgZmlyZUl0ZW0gPSBhc3luYyAoe1xuICBpbmRleCxcbiAgcXVldWVJdGVtcyxcbiAgd2FpdDogd2FpdDIsXG4gIGN1cnNvcixcbiAgY3Vyc29yT3B0aW9uc1xufSkgPT4ge1xuICBsZXQgcXVldWVJdGVtID0gcXVldWVJdGVtc1tpbmRleF1bMV07XG4gIGxldCBpbnN0YW50UXVldWUgPSBbXTtcbiAgbGV0IHRlbXBJbmRleCA9IGluZGV4O1xuICBsZXQgZnV0dXJlSXRlbSA9IHF1ZXVlSXRlbTtcbiAgbGV0IHNob3VsZEJlR3JvdXBlZCA9ICgpID0+IGZ1dHVyZUl0ZW0gJiYgIWZ1dHVyZUl0ZW0uZGVsYXk7XG4gIGxldCBzaG91bGRQYXVzZUN1cnNvciA9IHF1ZXVlSXRlbS5zaG91bGRQYXVzZUN1cnNvcigpICYmIGN1cnNvck9wdGlvbnMuYXV0b1BhdXNlO1xuICB3aGlsZSAoc2hvdWxkQmVHcm91cGVkKCkpIHtcbiAgICBpbnN0YW50UXVldWUucHVzaChmdXR1cmVJdGVtKTtcbiAgICBzaG91bGRCZUdyb3VwZWQoKSAmJiB0ZW1wSW5kZXgrKztcbiAgICBmdXR1cmVJdGVtID0gcXVldWVJdGVtc1t0ZW1wSW5kZXhdID8gcXVldWVJdGVtc1t0ZW1wSW5kZXhdWzFdIDogbnVsbDtcbiAgfVxuICBpZiAoaW5zdGFudFF1ZXVlLmxlbmd0aCkge1xuICAgIGF3YWl0IGJlZm9yZVBhaW50KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAobGV0IHEgb2YgaW5zdGFudFF1ZXVlKSB7XG4gICAgICAgIGF3YWl0IGV4ZWN1dGUocSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRlbXBJbmRleCAtIDE7XG4gIH1cbiAgbGV0IGFuaW1hdGlvbiA9IGdldEFuaW1hdGlvbkZyb21FbGVtZW50KGN1cnNvcik7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC4uLmFuaW1hdGlvbi5lZmZlY3QuZ2V0Q29tcHV0ZWRUaW1pbmcoKSxcbiAgICAgIGRlbGF5OiBzaG91bGRQYXVzZUN1cnNvciA/IGN1cnNvck9wdGlvbnMuYXV0b1BhdXNlRGVsYXkgOiAwXG4gICAgfTtcbiAgfVxuICBhd2FpdCB3YWl0Mihhc3luYyAoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbiAmJiBzaG91bGRQYXVzZUN1cnNvcikge1xuICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhd2FpdCBiZWZvcmVQYWludCgoKSA9PiB7XG4gICAgICBleGVjdXRlKHF1ZXVlSXRlbSk7XG4gICAgfSk7XG4gIH0sIHF1ZXVlSXRlbS5kZWxheSk7XG4gIGF3YWl0IHJlYnVpbGRDdXJzb3JBbmltYXRpb24oe1xuICAgIGN1cnNvcixcbiAgICBvcHRpb25zLFxuICAgIGN1cnNvck9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBpbmRleDtcbn07XG5jb25zdCBmaXJlV2hlblZpc2libGUgPSAoZWxlbWVudCwgZnVuYykgPT4ge1xuICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgKGVudHJpZXMsIG9ic2VydmVyMikgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB7IHRocmVzaG9sZDogMSB9XG4gICk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG59O1xuY29uc3QgZ2VuZXJhdGVIYXNoID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cmluZygyLCA5KTtcbmNvbnN0IGlzSW5wdXQgPSAoZWwpID0+IHtcbiAgcmV0dXJuIFwidmFsdWVcIiBpbiBlbDtcbn07XG5sZXQgZ2V0QWxsQ2hhcnMgPSAoZWxlbWVudCkgPT4ge1xuICBpZiAoaXNJbnB1dChlbGVtZW50KSkge1xuICAgIHJldHVybiB0b0FycmF5KGVsZW1lbnQudmFsdWUpO1xuICB9XG4gIHJldHVybiB3YWxrRWxlbWVudE5vZGVzKGVsZW1lbnQsIHRydWUpLmZpbHRlcihcbiAgICAoYykgPT4gIShjLmNoaWxkTm9kZXMubGVuZ3RoID4gMClcbiAgKTtcbn07XG5sZXQgaGFuZGxlRnVuY3Rpb25hbEFyZyA9IChhcmcpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiA/IGFyZygpIDogYXJnO1xufTtcbmxldCBzZWxlY3QgPSAoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudCwgYWxsID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIGVsZW1lbnRbYHF1ZXJ5U2VsZWN0b3Ike2FsbCA/IFwiQWxsXCIgOiBcIlwifWBdKHNlbGVjdG9yKTtcbn07XG5sZXQgaXNCb2R5RWxlbWVudCA9IChub2RlKSA9PiAvYm9keS9pLnRlc3Qobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKTtcbmxldCBpbnNlcnRJbnRvRWxlbWVudCA9IChvcmlnaW5hbFRhcmdldCwgY2hhcmFjdGVyKSA9PiB7XG4gIGlmIChpc0lucHV0KG9yaWdpbmFsVGFyZ2V0KSkge1xuICAgIG9yaWdpbmFsVGFyZ2V0LnZhbHVlID0gYCR7b3JpZ2luYWxUYXJnZXQudmFsdWV9JHtjaGFyYWN0ZXIudGV4dENvbnRlbnR9YDtcbiAgICByZXR1cm47XG4gIH1cbiAgY2hhcmFjdGVyLmlubmVySFRNTCA9IFwiXCI7XG4gIGxldCB0YXJnZXQgPSBpc0JvZHlFbGVtZW50KGNoYXJhY3Rlci5vcmlnaW5hbFBhcmVudCkgPyBvcmlnaW5hbFRhcmdldCA6IChcbiAgICAvLyBJZiB3ZSBhZGQgb25lLW9mZiBmcmVzaCBlbGVtZW50cywgdGhlcmUgd2lsbCBiZSBub1xuICAgIC8vIFwib3JpZ2luYWxQYXJlbnRcIiwgc28gYWx3YXlzIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB0YXJnZXQuXG4gICAgY2hhcmFjdGVyLm9yaWdpbmFsUGFyZW50IHx8IG9yaWdpbmFsVGFyZ2V0XG4gICk7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUoXG4gICAgY2hhcmFjdGVyLFxuICAgIHNlbGVjdChcIi5cIiArIENVUlNPUl9DTEFTUywgdGFyZ2V0KSB8fCBudWxsXG4gICk7XG59O1xuY29uc3QgaXNOb25Wb2lkRWxlbWVudCA9IChlbCkgPT4gLzwoLispPiguKj8pPFxcLyguKyk+Ly50ZXN0KGVsLm91dGVySFRNTCk7XG5jb25zdCBtZXJnZSA9IChvcmlnaW5hbE9iaiwgbmV3T2JqKSA9PiBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbE9iaiwgbmV3T2JqKTtcbmxldCBwcm9jZXNzQ3Vyc29yT3B0aW9ucyA9IChjdXJzb3JPcHRpb25zKSA9PiB7XG4gIHZhciBfYTIsIF9iO1xuICBpZiAodHlwZW9mIGN1cnNvck9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbmV3T3B0aW9ucyA9IHt9O1xuICAgIGxldCB7IGZyYW1lczogZGVmYXVsdEZyYW1lcywgb3B0aW9uczogZGVmYXVsdE9wdGlvbnMgfSA9IERFRkFVTFRfT1BUSU9OUy5jdXJzb3IuYW5pbWF0aW9uO1xuICAgIG5ld09wdGlvbnMuYW5pbWF0aW9uID0gY3Vyc29yT3B0aW9ucy5hbmltYXRpb24gfHwge307XG4gICAgbmV3T3B0aW9ucy5hbmltYXRpb24uZnJhbWVzID0gKChfYTIgPSBjdXJzb3JPcHRpb25zLmFuaW1hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5mcmFtZXMpIHx8IGRlZmF1bHRGcmFtZXM7XG4gICAgbmV3T3B0aW9ucy5hbmltYXRpb24ub3B0aW9ucyA9IG1lcmdlKFxuICAgICAgZGVmYXVsdE9wdGlvbnMsXG4gICAgICAoKF9iID0gY3Vyc29yT3B0aW9ucy5hbmltYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5vcHRpb25zKSB8fCB7fVxuICAgICk7XG4gICAgbmV3T3B0aW9ucy5hdXRvUGF1c2UgPSBjdXJzb3JPcHRpb25zLmF1dG9QYXVzZSA/PyBERUZBVUxUX09QVElPTlMuY3Vyc29yLmF1dG9QYXVzZTtcbiAgICBuZXdPcHRpb25zLmF1dG9QYXVzZURlbGF5ID0gY3Vyc29yT3B0aW9ucy5hdXRvUGF1c2VEZWxheSB8fCBERUZBVUxUX09QVElPTlMuY3Vyc29yLmF1dG9QYXVzZURlbGF5O1xuICAgIHJldHVybiBuZXdPcHRpb25zO1xuICB9XG4gIGlmIChjdXJzb3JPcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfT1BUSU9OUy5jdXJzb3I7XG4gIH1cbiAgcmV0dXJuIGN1cnNvck9wdGlvbnM7XG59O1xuY29uc3QgcmVtb3ZlTm9kZSA9IChub2RlLCByb290RWxlbWVudCkgPT4ge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgbGV0IG5vZGVQYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGxldCBub2RlVG9SZW1vdmUgPSBub2RlUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fCBub2RlUGFyZW50LmlzU2FtZU5vZGUocm9vdEVsZW1lbnQpID8gKFxuICAgIC8vIFRoaXMgcGFyZW50IHN0aWxsIG5lZWRzIHRvIGV4aXN0LlxuICAgIG5vZGVcbiAgKSA6IChcbiAgICAvLyBUaGVyZSdzIG5vdGhpbmcgZWxzZSBpbiB0aGVyZSwgc28ganVzdCBkZWxldGUgdGhlIGVudGlyZSB0aGluZy5cbiAgICAvLyBCeSBkb2luZyB0aGlzLCB3ZSBjbGVhbiB1cCBtYXJrdXAgYXMgd2UgZ28gYWxvbmcuXG4gICAgbm9kZVBhcmVudFxuICApO1xuICBub2RlVG9SZW1vdmUucmVtb3ZlKCk7XG59O1xuY29uc3QgcmVwb3NpdGlvbkN1cnNvciA9IChlbGVtZW50LCBhbGxDaGFycywgbmV3Q3Vyc29yUG9zaXRpb24pID0+IHtcbiAgbGV0IG5vZGVUb0luc2VydEJlZm9yZSA9IGFsbENoYXJzW25ld0N1cnNvclBvc2l0aW9uIC0gMV07XG4gIGxldCBjdXJzb3IgPSBzZWxlY3QoYC4ke0NVUlNPUl9DTEFTU31gLCBlbGVtZW50KTtcbiAgZWxlbWVudCA9IChub2RlVG9JbnNlcnRCZWZvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVUb0luc2VydEJlZm9yZS5wYXJlbnROb2RlKSB8fCBlbGVtZW50O1xuICBlbGVtZW50Lmluc2VydEJlZm9yZShjdXJzb3IsIG5vZGVUb0luc2VydEJlZm9yZSB8fCBudWxsKTtcbn07XG5mdW5jdGlvbiBzZWxlY3RvclRvRWxlbWVudCh0aGluZykge1xuICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSBcInN0cmluZ1wiID8gc2VsZWN0KHRoaW5nKSA6IHRoaW5nO1xufVxubGV0IGN1cnNvckZvbnRTdHlsZXMgPSB7XG4gIFwiZm9udC1mYW1pbHlcIjogXCJcIixcbiAgXCJmb250LXdlaWdodFwiOiBcIlwiLFxuICBcImZvbnQtc2l6ZVwiOiBcIlwiLFxuICBcImZvbnQtc3R5bGVcIjogXCJcIixcbiAgXCJsaW5lLWhlaWdodFwiOiBcIlwiLFxuICBjb2xvcjogXCJcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLS4xMjVlbSlcIlxufTtcbmxldCBzZXRDdXJzb3JTdHlsZXMgPSAoaWQsIGVsZW1lbnQpID0+IHtcbiAgbGV0IHJvb3RTZWxlY3RvciA9IGBbJHtEQVRBX0FUVFJJQlVURX09JyR7aWR9J11gO1xuICBsZXQgY3Vyc29yU2VsZWN0b3IgPSBgJHtyb290U2VsZWN0b3J9IC4ke0NVUlNPUl9DTEFTU31gO1xuICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBsZXQgY3VzdG9tUHJvcGVydGllcyA9IE9iamVjdC5lbnRyaWVzKGN1cnNvckZvbnRTdHlsZXMpLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIFtpdGVtLCB2YWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBgJHthY2N1bXVsYXRvcn0gJHtpdGVtfTogdmFyKC0tdGktY3Vyc29yLSR7aXRlbX0sICR7dmFsdWUgfHwgY29tcHV0ZWRTdHlsZXNbaXRlbV19KTtgO1xuICAgIH0sXG4gICAgXCJcIlxuICApO1xuICBhcHBlbmRTdHlsZUJsb2NrKFxuICAgIGAke2N1cnNvclNlbGVjdG9yfSB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDA7ICR7Y3VzdG9tUHJvcGVydGllc30gfWAsXG4gICAgaWRcbiAgKTtcbn07XG5mdW5jdGlvbiBzcGxpdE9uQnJlYWsoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvPCEtLSguKz8pLS0+L2csIFwiXCIpLnRyaW0oKS5zcGxpdCgvPGJyKD86XFxzKj8pKD86XFwvKT8+Lyk7XG59XG5sZXQgdXBkYXRlQ3Vyc29yUG9zaXRpb24gPSAoc3RlcHMsIGN1cnNvclBvc2l0aW9uLCBwcmludGVkQ2hhcmFjdGVycykgPT4ge1xuICByZXR1cm4gTWF0aC5taW4oXG4gICAgTWF0aC5tYXgoY3Vyc29yUG9zaXRpb24gKyBzdGVwcywgMCksXG4gICAgcHJpbnRlZENoYXJhY3RlcnMubGVuZ3RoXG4gICk7XG59O1xubGV0IHdhaXQgPSAoY2FsbGJhY2ssIGRlbGF5LCB0aW1lb3V0cykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsZXQgY2IgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgdGltZW91dHMucHVzaChzZXRUaW1lb3V0KGNiLCBkZWxheSB8fCAwKSk7XG4gIH0pO1xufTtcbmxldCBUeXBlSXQkMSA9IChfYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZWxlbWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGltZW91dHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImN1cnNvclBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcmVkaWN0ZWRDdXJzb3JQb3NpdGlvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdHVzZXNcIiwge1xuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZnJvemVuOiBmYWxzZSxcbiAgICAgIGRlc3Ryb3llZDogZmFsc2VcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInF1ZXVlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjdXJzb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuZnJlZXplXCIsICgpID0+IHtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNcIiwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0dXNlc1trZXldO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYnVpbGRPcHRpb25zLCAob3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucy5jdXJzb3IgPSBwcm9jZXNzQ3Vyc29yT3B0aW9ucyhcbiAgICAgICAgb3B0aW9ucy5jdXJzb3IgPz8gREVGQVVMVF9PUFRJT05TLmN1cnNvclxuICAgICAgKTtcbiAgICAgIHRoaXMub3B0cy5zdHJpbmdzID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBwcmVwZW5kSGFyZGNvZGVkU3RyaW5nc19mbikuY2FsbCh0aGlzLCBhc0FycmF5KHRoaXMub3B0cy5zdHJpbmdzKSk7XG4gICAgICB0aGlzLm9wdHMgPSBtZXJnZSh0aGlzLm9wdHMsIHtcbiAgICAgICAgaHRtbDogIV9fcHJpdmF0ZUdldCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgaXNJbnB1dF9nZXQpICYmIHRoaXMub3B0cy5odG1sLFxuICAgICAgICBuZXh0U3RyaW5nRGVsYXk6IGNhbGN1bGF0ZURlbGF5KHRoaXMub3B0cy5uZXh0U3RyaW5nRGVsYXkpLFxuICAgICAgICBsb29wRGVsYXk6IGNhbGN1bGF0ZURlbGF5KHRoaXMub3B0cy5sb29wRGVsYXkpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLm9wdHMgPSBtZXJnZShERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudCA9IHNlbGVjdG9yVG9FbGVtZW50KGVsZW1lbnQpO1xuICAgIHRoaXMudGltZW91dHMgPSBbXTtcbiAgICB0aGlzLmN1cnNvclBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnVuZnJlZXplID0gKCkgPT4ge1xuICAgIH07XG4gICAgdGhpcy5wcmVkaWN0ZWRDdXJzb3JQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zdGF0dXNlcyA9IG1lcmdlKHt9LCBERUZBVUxUX1NUQVRVU0VTKTtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVIYXNoKCk7XG4gICAgdGhpcy5xdWV1ZSA9IFF1ZXVlKFt7IGRlbGF5OiB0aGlzLm9wdHMuc3RhcnREZWxheSB9XSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idWlsZE9wdGlvbnMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5jdXJzb3IgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHNldFVwQ3Vyc29yX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxlbWVudC5kYXRhc2V0LnR5cGVpdElkID0gdGhpcy5pZDtcbiAgICBhcHBlbmRTdHlsZUJsb2NrKFBMQUNFSE9MREVSX0NTUyk7XG4gICAgaWYgKHRoaXMub3B0cy5zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBnZW5lcmF0ZVF1ZXVlX2ZuKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAqL1xuICBnbygpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNlcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhdHRhY2hDdXJzb3JfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdFVudGlsVmlzaWJsZSkge1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBmaXJlX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpcmVXaGVuVmlzaWJsZSh0aGlzLmVsZW1lbnQsIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZmlyZV9mbikuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzdHJveShzaG91bGRSZW1vdmVDdXJzb3IgPSB0cnVlKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IGRlc3Ryb3lUaW1lb3V0cyh0aGlzLnRpbWVvdXRzKTtcbiAgICBoYW5kbGVGdW5jdGlvbmFsQXJnKHNob3VsZFJlbW92ZUN1cnNvcikgJiYgdGhpcy5jdXJzb3IgJiYgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCByZW1vdmVOb2RlX2ZuKS5jYWxsKHRoaXMsIHRoaXMuY3Vyc29yKTtcbiAgICB0aGlzLnN0YXR1c2VzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgcmVzZXQocmVidWlsZCkge1xuICAgICF0aGlzLmlzKFwiZGVzdHJveWVkXCIpICYmIHRoaXMuZGVzdHJveSgpO1xuICAgIGlmIChyZWJ1aWxkKSB7XG4gICAgICB0aGlzLnF1ZXVlLndpcGUoKTtcbiAgICAgIHJlYnVpbGQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWUucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5zdGF0dXNlcykge1xuICAgICAgdGhpcy5zdGF0dXNlc1twcm9wZXJ0eV0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50W19fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZWxlbWVudElzSW5wdXRfZm4pLmNhbGwodGhpcykgPyBcInZhbHVlXCIgOiBcImlubmVySFRNTFwiXSA9IFwiXCI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHlwZShzdHJpbmcsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHN0cmluZyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcoc3RyaW5nKTtcbiAgICBsZXQgeyBpbnN0YW50IH0gPSBhY3Rpb25PcHRzO1xuICAgIGxldCBib29rRW5kUXVldWVJdGVtcyA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zX2ZuKS5jYWxsKHRoaXMsIGFjdGlvbk9wdHMpO1xuICAgIGxldCBjaGFycyA9IG1heWJlQ2h1bmtTdHJpbmdBc0h0bWwoc3RyaW5nLCB0aGlzLm9wdHMuaHRtbCk7XG4gICAgbGV0IGNoYXJzQXNRdWV1ZUl0ZW1zID0gY2hhcnMubWFwKChjaGFyKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmdW5jOiAoKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHR5cGVfZm4pLmNhbGwodGhpcywgY2hhciksXG4gICAgICAgIGNoYXIsXG4gICAgICAgIGRlbGF5OiBpbnN0YW50IHx8IGlzTm9uVm9pZEVsZW1lbnQoY2hhcikgPyAwIDogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBnZXRQYWNlX2ZuKS5jYWxsKHRoaXMpLFxuICAgICAgICB0eXBlYWJsZTogY2hhci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IGl0ZW1zVG9RdWV1ZSA9IFtcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgeyBmdW5jOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLm9wdHMuYmVmb3JlU3RyaW5nKHN0cmluZywgdGhpcykgfSxcbiAgICAgIC4uLmNoYXJzQXNRdWV1ZUl0ZW1zLFxuICAgICAgeyBmdW5jOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLm9wdHMuYWZ0ZXJTdHJpbmcoc3RyaW5nLCB0aGlzKSB9LFxuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICBdO1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHF1ZXVlQW5kUmV0dXJuX2ZuKS5jYWxsKHRoaXMsIGl0ZW1zVG9RdWV1ZSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgYnJlYWsoYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywge1xuICAgICAgZnVuYzogKCkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCB0eXBlX2ZuKS5jYWxsKHRoaXMsIGNyZWF0ZUVsZW1lbnQoXCJCUlwiKSksXG4gICAgICB0eXBlYWJsZTogdHJ1ZVxuICAgIH0sIGFjdGlvbk9wdHMpO1xuICB9XG4gIG1vdmUobW92ZW1lbnRBcmcsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIG1vdmVtZW50QXJnID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhtb3ZlbWVudEFyZyk7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXNfZm4pLmNhbGwodGhpcywgYWN0aW9uT3B0cyk7XG4gICAgbGV0IHsgaW5zdGFudCwgdG8gfSA9IGFjdGlvbk9wdHM7XG4gICAgbGV0IG51bWJlck9mU3RlcHMgPSBjb3VudFN0ZXBzVG9TZWxlY3Rvcih7XG4gICAgICBxdWV1ZUl0ZW1zOiB0aGlzLnF1ZXVlLmdldFR5cGVhYmxlKCksXG4gICAgICBzZWxlY3RvcjogbW92ZW1lbnRBcmcgPT09IG51bGwgPyBcIlwiIDogbW92ZW1lbnRBcmcsXG4gICAgICB0byxcbiAgICAgIGN1cnNvclBvc2l0aW9uOiBfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGRlcml2ZWRDdXJzb3JQb3NpdGlvbl9nZXQpXG4gICAgfSk7XG4gICAgbGV0IGRpcmVjdGlvbmFsU3RlcCA9IG51bWJlck9mU3RlcHMgPCAwID8gLTEgOiAxO1xuICAgIHRoaXMucHJlZGljdGVkQ3Vyc29yUG9zaXRpb24gPSBfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGRlcml2ZWRDdXJzb3JQb3NpdGlvbl9nZXQpICsgbnVtYmVyT2ZTdGVwcztcbiAgICByZXR1cm4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBxdWV1ZUFuZFJldHVybl9mbikuY2FsbCh0aGlzLCBbXG4gICAgICBib29rRW5kUXVldWVJdGVtc1swXSxcbiAgICAgIC4uLmR1cGxpY2F0ZShcbiAgICAgICAge1xuICAgICAgICAgIGZ1bmM6ICgpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgbW92ZV9mbikuY2FsbCh0aGlzLCBkaXJlY3Rpb25hbFN0ZXApLFxuICAgICAgICAgIGRlbGF5OiBpbnN0YW50ID8gMCA6IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZ2V0UGFjZV9mbikuY2FsbCh0aGlzKSxcbiAgICAgICAgICBjdXJzb3JhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIE1hdGguYWJzKG51bWJlck9mU3RlcHMpXG4gICAgICApLFxuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICBdLCBhY3Rpb25PcHRzKTtcbiAgfVxuICBleGVjKGZ1bmMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIGxldCBib29rRW5kUXVldWVJdGVtcyA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zX2ZuKS5jYWxsKHRoaXMsIGFjdGlvbk9wdHMpO1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHF1ZXVlQW5kUmV0dXJuX2ZuKS5jYWxsKHRoaXMsIFtib29rRW5kUXVldWVJdGVtc1swXSwgeyBmdW5jOiAoKSA9PiBmdW5jKHRoaXMpIH0sIGJvb2tFbmRRdWV1ZUl0ZW1zWzFdXSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgb3B0aW9ucyhvcHRzLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBvcHRzID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhvcHRzKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHVwZGF0ZU9wdGlvbnNfZm4pLmNhbGwodGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywge30sIGFjdGlvbk9wdHMpO1xuICB9XG4gIHBhdXNlKG1pbGxpc2Vjb25kcywgYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywgeyBkZWxheTogaGFuZGxlRnVuY3Rpb25hbEFyZyhtaWxsaXNlY29uZHMpIH0sIGFjdGlvbk9wdHMpO1xuICB9XG4gIGRlbGV0ZShudW1DaGFyYWN0ZXJzID0gbnVsbCwgYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgbnVtQ2hhcmFjdGVycyA9IGhhbmRsZUZ1bmN0aW9uYWxBcmcobnVtQ2hhcmFjdGVycyk7XG4gICAgbGV0IGJvb2tFbmRRdWV1ZUl0ZW1zID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXNfZm4pLmNhbGwodGhpcywgYWN0aW9uT3B0cyk7XG4gICAgbGV0IG51bSA9IG51bUNoYXJhY3RlcnM7XG4gICAgbGV0IHsgaW5zdGFudCwgdG8gfSA9IGFjdGlvbk9wdHM7XG4gICAgbGV0IHR5cGVhYmxlUXVldWVJdGVtcyA9IHRoaXMucXVldWUuZ2V0VHlwZWFibGUoKTtcbiAgICBsZXQgcm91bmRzID0gKCgpID0+IHtcbiAgICAgIGlmIChudW0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVhYmxlUXVldWVJdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1iZXIobnVtKSkge1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50U3RlcHNUb1NlbGVjdG9yKHtcbiAgICAgICAgcXVldWVJdGVtczogdHlwZWFibGVRdWV1ZUl0ZW1zLFxuICAgICAgICBzZWxlY3RvcjogbnVtLFxuICAgICAgICBjdXJzb3JQb3NpdGlvbjogX19wcml2YXRlR2V0KHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0KSxcbiAgICAgICAgdG9cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywgW1xuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMF0sXG4gICAgICAuLi5kdXBsaWNhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICBmdW5jOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGRlbGV0ZV9mbikuYmluZCh0aGlzKSxcbiAgICAgICAgICBkZWxheTogaW5zdGFudCA/IDAgOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgICAgZGVsZXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kc1xuICAgICAgKSxcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzFdXG4gICAgXSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuc3RhdHVzZXMuZnJvemVuID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmdvKClgLCBidXQgbW9yZS4uLiBcIm9mZiB0aGUgZ3JpZC5cIlxuICAgKlxuICAgKiAtIHdvbid0IHRyaWdnZXIgYGFmdGVyQ29tcGxldGVgIGNhbGxiYWNrXG4gICAqIC0gaXRlbXMgd29uJ3QgYmUgcmVwbGF5ZWQgYWZ0ZXIgYC5yZXNldCgpYFxuICAgKlxuICAgKiBXaGVuIGNhbGxlZCwgYWxsIG5vbi1kb25lIGl0ZW1zIHdpbGwgYmUgXCJmbHVzaGVkXCIgLS1cbiAgICogdGhhdCBpcywgZXhlY3V0ZWQsIGJ1dCBub3QgcmVtZW1iZXJlZC5cbiAgICovXG4gIGZsdXNoKGNiID0gKCkgPT4ge1xuICB9KSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhdHRhY2hDdXJzb3JfZm4pLmNhbGwodGhpcyk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBmaXJlX2ZuKS5jYWxsKHRoaXMsIGZhbHNlKS50aGVuKGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRRdWV1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM7XG4gIH1cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgdXBkYXRlT3B0aW9uc19mbikuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gIH1cbiAgZW1wdHkoYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywgeyBmdW5jOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGVtcHR5X2ZuKS5iaW5kKHRoaXMpIH0sIGFjdGlvbk9wdHMpO1xuICB9XG59LCBfVHlwZUl0X2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIGVtcHR5X2ZuID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGlmIChfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGVsZW1lbnRJc0lucHV0X2ZuKS5jYWxsKHRoaXMpKSB7XG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICByZXR1cm47XG4gIH1cbiAgX19wcml2YXRlR2V0KHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhbGxDaGFyc19nZXQpLmZvckVhY2goX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCByZW1vdmVOb2RlX2ZuKS5iaW5kKHRoaXMpKTtcbiAgcmV0dXJuO1xufSwgZmlyZV9mbiA9IGFzeW5jIGZ1bmN0aW9uKHJlbWVtYmVyID0gdHJ1ZSkge1xuICB0aGlzLnN0YXR1c2VzLnN0YXJ0ZWQgPSB0cnVlO1xuICBsZXQgY2xlYW5VcCA9IChxS2V5KSA9PiB7XG4gICAgdGhpcy5xdWV1ZS5kb25lKHFLZXksICFyZW1lbWJlcik7XG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IHF1ZXVlSXRlbXMgPSBbLi4udGhpcy5xdWV1ZS5nZXRRdWV1ZSgpXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcXVldWVJdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBbcXVldWVLZXksIHF1ZXVlSXRlbV0gPSBxdWV1ZUl0ZW1zW2luZGV4XTtcbiAgICAgIGlmIChxdWV1ZUl0ZW0uZG9uZSkgY29udGludWU7XG4gICAgICBpZiAoIXF1ZXVlSXRlbS5kZWxldGFibGUgfHwgcXVldWVJdGVtLmRlbGV0YWJsZSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGFsbENoYXJzX2dldCkubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXdJbmRleCA9IGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZmlyZUl0ZW1XaXRoQ29udGV4dF9mbikuY2FsbCh0aGlzLCBpbmRleCwgcXVldWVJdGVtcyk7XG4gICAgICAgIGNsZWFuVXBTa2lwcGVkKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBuZXdJbmRleCxcbiAgICAgICAgICBxdWV1ZUl0ZW1zLFxuICAgICAgICAgIGNsZWFuVXBcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbmV3SW5kZXg7XG4gICAgICB9XG4gICAgICBjbGVhblVwKHF1ZXVlS2V5KTtcbiAgICB9XG4gICAgaWYgKCFyZW1lbWJlcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzZXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICBhd2FpdCB0aGlzLm9wdHMuYWZ0ZXJDb21wbGV0ZSh0aGlzKTtcbiAgICBpZiAoIXRoaXMub3B0cy5sb29wKSB7XG4gICAgICB0aHJvdyBcIlwiO1xuICAgIH1cbiAgICBsZXQgZGVsYXkgPSB0aGlzLm9wdHMubG9vcERlbGF5O1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgd2FpdF9mbikuY2FsbCh0aGlzLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHByZXBMb29wX2ZuKS5jYWxsKHRoaXMsIGRlbGF5WzBdKTtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZmlyZV9mbikuY2FsbCh0aGlzKTtcbiAgICB9LCBkZWxheVsxXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gdGhpcztcbn0sIG1vdmVfZm4gPSBhc3luYyBmdW5jdGlvbihzdGVwKSB7XG4gIHRoaXMuY3Vyc29yUG9zaXRpb24gPSB1cGRhdGVDdXJzb3JQb3NpdGlvbihcbiAgICBzdGVwLFxuICAgIHRoaXMuY3Vyc29yUG9zaXRpb24sXG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhbGxDaGFyc19nZXQpXG4gICk7XG4gIHJlcG9zaXRpb25DdXJzb3IodGhpcy5lbGVtZW50LCBfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGFsbENoYXJzX2dldCksIHRoaXMuY3Vyc29yUG9zaXRpb24pO1xufSwgcHJlcExvb3BfZm4gPSBhc3luYyBmdW5jdGlvbihkZWxheSkge1xuICBsZXQgZGVyaXZlZEN1cnNvclBvc2l0aW9uID0gX19wcml2YXRlR2V0KHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0KTtcbiAgZGVyaXZlZEN1cnNvclBvc2l0aW9uICYmIGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgbW92ZV9mbikuY2FsbCh0aGlzLCB7IHZhbHVlOiBkZXJpdmVkQ3Vyc29yUG9zaXRpb24gfSk7XG4gIGxldCBxdWV1ZUl0ZW1zID0gX19wcml2YXRlR2V0KHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhbGxDaGFyc19nZXQpLm1hcCgoYykgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICBTeW1ib2woKSxcbiAgICAgIHtcbiAgICAgICAgZnVuYzogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBkZWxldGVfZm4pLmJpbmQodGhpcyksXG4gICAgICAgIGRlbGF5OiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgIGRlbGV0YWJsZTogdHJ1ZSxcbiAgICAgICAgc2hvdWxkUGF1c2VDdXJzb3I6ICgpID0+IHRydWVcbiAgICAgIH1cbiAgICBdO1xuICB9KTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlSXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBmaXJlSXRlbVdpdGhDb250ZXh0X2ZuKS5jYWxsKHRoaXMsIGluZGV4LCBxdWV1ZUl0ZW1zKTtcbiAgfVxuICB0aGlzLnF1ZXVlLnJlc2V0KCk7XG4gIHRoaXMucXVldWUuc2V0KDAsIHsgZGVsYXkgfSk7XG59LCBmaXJlSXRlbVdpdGhDb250ZXh0X2ZuID0gZnVuY3Rpb24oaW5kZXgsIHF1ZXVlSXRlbXMpIHtcbiAgcmV0dXJuIGZpcmVJdGVtKHtcbiAgICBpbmRleCxcbiAgICBxdWV1ZUl0ZW1zLFxuICAgIHdhaXQ6IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgd2FpdF9mbikuYmluZCh0aGlzKSxcbiAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgIGN1cnNvck9wdGlvbnM6IHRoaXMub3B0cy5jdXJzb3JcbiAgfSk7XG59LCB3YWl0X2ZuID0gYXN5bmMgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCBzaWxlbnQgPSBmYWxzZSkge1xuICBpZiAodGhpcy5zdGF0dXNlcy5mcm96ZW4pIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy51bmZyZWV6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0dXNlcy5mcm96ZW4gPSBmYWxzZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBzaWxlbnQgfHwgYXdhaXQgdGhpcy5vcHRzLmJlZm9yZVN0ZXAodGhpcyk7XG4gIGF3YWl0IHdhaXQoY2FsbGJhY2ssIGRlbGF5LCB0aGlzLnRpbWVvdXRzKTtcbiAgc2lsZW50IHx8IGF3YWl0IHRoaXMub3B0cy5hZnRlclN0ZXAodGhpcyk7XG59LCBhdHRhY2hDdXJzb3JfZm4gPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgIV9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgZWxlbWVudElzSW5wdXRfZm4pLmNhbGwodGhpcykgJiYgdGhpcy5jdXJzb3IgJiYgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY3Vyc29yKTtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgc2hvdWxkUmVuZGVyQ3Vyc29yX2dldCkpIHtcbiAgICBzZXRDdXJzb3JTdHlsZXModGhpcy5pZCwgdGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmN1cnNvci5kYXRhc2V0LnRpQW5pbWF0aW9uSWQgPSB0aGlzLmlkO1xuICAgIGxldCB7IGFuaW1hdGlvbiB9ID0gdGhpcy5vcHRzLmN1cnNvcjtcbiAgICBsZXQgeyBmcmFtZXMsIG9wdGlvbnMgfSA9IGFuaW1hdGlvbjtcbiAgICBzZXRDdXJzb3JBbmltYXRpb24oe1xuICAgICAgZnJhbWVzLFxuICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvcixcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0cy5jdXJzb3JTcGVlZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59LCBlbGVtZW50SXNJbnB1dF9mbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaXNJbnB1dCh0aGlzLmVsZW1lbnQpO1xufSwgcXVldWVBbmRSZXR1cm5fZm4gPSBmdW5jdGlvbihzdGVwcywgb3B0cykge1xuICB0aGlzLnF1ZXVlLmFkZChzdGVwcyk7XG4gIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgbWF5YmVBcHBlbmRQYXVzZV9mbikuY2FsbCh0aGlzLCBvcHRzKTtcbiAgcmV0dXJuIHRoaXM7XG59LCBtYXliZUFwcGVuZFBhdXNlX2ZuID0gZnVuY3Rpb24ob3B0cyA9IHt9KSB7XG4gIGxldCBkZWxheSA9IG9wdHMuZGVsYXk7XG4gIGRlbGF5ICYmIHRoaXMucXVldWUuYWRkKHsgZGVsYXkgfSk7XG59LCBnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXNfZm4gPSBmdW5jdGlvbihuZXdPcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIFtcbiAgICB7IGZ1bmM6ICgpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgdXBkYXRlT3B0aW9uc19mbikuY2FsbCh0aGlzLCBuZXdPcHRpb25zKSB9LFxuICAgIHsgZnVuYzogKCkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCB1cGRhdGVPcHRpb25zX2ZuKS5jYWxsKHRoaXMsIHRoaXMub3B0cykgfVxuICBdO1xufSwgdXBkYXRlT3B0aW9uc19mbiA9IGFzeW5jIGZ1bmN0aW9uKG9wdHMpIHtcbiAgdGhpcy5vcHRzID0gbWVyZ2UodGhpcy5vcHRzLCBvcHRzKTtcbn0sIC8qKlxuICogQmFzZWQgb24gcHJvdmlkZWQgc3RyaW5ncywgZ2VuZXJhdGUgYSBUeXBlSXQgcXVldWVcbiAqIHRvIGJlIGZpcmVkIGZvciBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlxuICovXG5nZW5lcmF0ZVF1ZXVlX2ZuID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzdHJpbmdzID0gdGhpcy5vcHRzLnN0cmluZ3MuZmlsdGVyKChzdHJpbmcpID0+ICEhc3RyaW5nKTtcbiAgc3RyaW5ncy5mb3JFYWNoKChzdHJpbmcsIGluZGV4KSA9PiB7XG4gICAgdGhpcy50eXBlKHN0cmluZyk7XG4gICAgaWYgKGluZGV4ICsgMSA9PT0gc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNwbGl0SXRlbXMgPSB0aGlzLm9wdHMuYnJlYWtMaW5lcyA/IFt7IGZ1bmM6ICgpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgdHlwZV9mbikuY2FsbCh0aGlzLCBjcmVhdGVFbGVtZW50KFwiQlJcIikpLCB0eXBlYWJsZTogdHJ1ZSB9XSA6IGR1cGxpY2F0ZShcbiAgICAgIHtcbiAgICAgICAgZnVuYzogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBkZWxldGVfZm4pLmJpbmQodGhpcyksXG4gICAgICAgIGRlbGF5OiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSlcbiAgICAgIH0sXG4gICAgICB0aGlzLnF1ZXVlLmdldFR5cGVhYmxlKCkubGVuZ3RoXG4gICAgKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGFkZFNwbGl0UGF1c2VfZm4pLmNhbGwodGhpcywgc3BsaXRJdGVtcyk7XG4gIH0pO1xufSwgX2J1aWxkT3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIHByZXBlbmRIYXJkY29kZWRTdHJpbmdzX2ZuID0gZnVuY3Rpb24oc3RyaW5ncykge1xuICBsZXQgZXhpc3RpbmdNYXJrdXAgPSB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MO1xuICBpZiAoIWV4aXN0aW5nTWFya3VwKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cbiAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gIGlmICh0aGlzLm9wdHMuc3RhcnREZWxldGUpIHtcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gZXhpc3RpbmdNYXJrdXA7XG4gICAgZXhwYW5kVGV4dE5vZGVzKHRoaXMuZWxlbWVudCk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBhZGRTcGxpdFBhdXNlX2ZuKS5jYWxsKHRoaXMsIGR1cGxpY2F0ZShcbiAgICAgIHtcbiAgICAgICAgZnVuYzogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCBkZWxldGVfZm4pLmJpbmQodGhpcyksXG4gICAgICAgIGRlbGF5OiBfX3ByaXZhdGVNZXRob2QodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgIGRlbGV0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgYWxsQ2hhcnNfZ2V0KS5sZW5ndGhcbiAgICApKTtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuICByZXR1cm4gc3BsaXRPbkJyZWFrKGV4aXN0aW5nTWFya3VwKS5jb25jYXQoc3RyaW5ncyk7XG59LCAvKipcbiAqIFByb3ZpZGVkIGl0J3MgYSBub24tZm9ybSBlbGVtZW50IGFuZCB0aGUgb3B0aW9ucyBpcyBwcm92aWRlZCxcbiAqIHNldCB1cCB0aGUgY3Vyc29yIGVsZW1lbnQgZm9yIHRoZSBhbmltYXRpb24uXG4gKi9cbnNldFVwQ3Vyc29yX2ZuID0gZnVuY3Rpb24oKSB7XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGlzSW5wdXRfZ2V0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBjdXJzb3IgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgY3Vyc29yLmNsYXNzTmFtZSA9IENVUlNPUl9DTEFTUztcbiAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIHNob3VsZFJlbmRlckN1cnNvcl9nZXQpKSB7XG4gICAgY3Vyc29yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIHJldHVybiBjdXJzb3I7XG4gIH1cbiAgY3Vyc29yLmlubmVySFRNTCA9IGdldFBhcnNlZEJvZHkodGhpcy5vcHRzLmN1cnNvckNoYXIpLmlubmVySFRNTDtcbiAgcmV0dXJuIGN1cnNvcjtcbn0sIGFkZFNwbGl0UGF1c2VfZm4gPSBmdW5jdGlvbihpdGVtcykge1xuICBsZXQgZGVsYXkgPSB0aGlzLm9wdHMubmV4dFN0cmluZ0RlbGF5O1xuICB0aGlzLnF1ZXVlLmFkZChbeyBkZWxheTogZGVsYXlbMF0gfSwgLi4uaXRlbXMsIHsgZGVsYXk6IGRlbGF5WzFdIH1dKTtcbn0sIHR5cGVfZm4gPSBmdW5jdGlvbihjaGFyKSB7XG4gIGluc2VydEludG9FbGVtZW50KHRoaXMuZWxlbWVudCwgY2hhcik7XG59LCBkZWxldGVfZm4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGFsbENoYXJzX2dldCkubGVuZ3RoKSByZXR1cm47XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGlzSW5wdXRfZ2V0KSkge1xuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZS5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9UeXBlSXRfaW5zdGFuY2VzLCByZW1vdmVOb2RlX2ZuKS5jYWxsKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfVHlwZUl0X2luc3RhbmNlcywgYWxsQ2hhcnNfZ2V0KVt0aGlzLmN1cnNvclBvc2l0aW9uXSk7XG4gIH1cbn0sIHJlbW92ZU5vZGVfZm4gPSBmdW5jdGlvbihub2RlKSB7XG4gIHJlbW92ZU5vZGUobm9kZSwgdGhpcy5lbGVtZW50KTtcbn0sIGdldFBhY2VfZm4gPSBmdW5jdGlvbihpbmRleCA9IDApIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVBhY2UodGhpcy5vcHRzKVtpbmRleF07XG59LCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByZWRpY3RlZEN1cnNvclBvc2l0aW9uID8/IHRoaXMuY3Vyc29yUG9zaXRpb247XG59LCBpc0lucHV0X2dldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaXNJbnB1dCh0aGlzLmVsZW1lbnQpO1xufSwgc2hvdWxkUmVuZGVyQ3Vyc29yX2dldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLm9wdHMuY3Vyc29yICYmICFfX3ByaXZhdGVHZXQodGhpcywgX1R5cGVJdF9pbnN0YW5jZXMsIGlzSW5wdXRfZ2V0KTtcbn0sIGFsbENoYXJzX2dldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2V0QWxsQ2hhcnModGhpcy5lbGVtZW50KTtcbn0sIF9hKTtcbmNvbnN0IER5bmFtaWNFbGVtZW50Q29tcG9uZW50ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCB7IGFzOiBBcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBcywgeyByZWYsIC4uLnByb3BzIH0pO1xufSk7XG5jb25zdCBkZWZhdWx0UHJvcE9wdGlvbnMgPSB7fTtcbmNvbnN0IFR5cGVJdCA9ICh7XG4gIGFzID0gXCJzcGFuXCIsXG4gIG9wdGlvbnMgPSBkZWZhdWx0UHJvcE9wdGlvbnMsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgZ2V0QmVmb3JlSW5pdCA9IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UsXG4gIGdldEFmdGVySW5pdCA9IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UsXG4gIC4uLnJlbWFpbmluZ1Byb3BzXG59KSA9PiB7XG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluc3RhbmNlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbc2hvdWxkU2hvd0NoaWxkcmVuLCBzZXRTaG91bGRTaG93Q2hpbGRyZW5dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpbnN0YW5jZU9wdGlvbnMsIHNldEluc3RhbmNlT3B0aW9uc10gPSB1c2VTdGF0ZShudWxsKTtcbiAgZnVuY3Rpb24gY2FsY3VsYXRlT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25zQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4gJiYgZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICBvcHRpb25zQ2xvbmUuc3RyaW5ncyA9IGVsZW1lbnRSZWYuY3VycmVudC5pbm5lckhUTUw7XG4gICAgfVxuICAgIHNldEluc3RhbmNlT3B0aW9ucyhvcHRpb25zQ2xvbmUpO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlTmV3SW5zdGFuY2UoKSB7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyBUeXBlSXQkMShlbGVtZW50UmVmLmN1cnJlbnQsIGluc3RhbmNlT3B0aW9ucyk7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IGdldEJlZm9yZUluaXQoaW5zdGFuY2VSZWYuY3VycmVudCk7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudC5nbygpO1xuICAgIGluc3RhbmNlUmVmLmN1cnJlbnQgPSBnZXRBZnRlckluaXQoaW5zdGFuY2VSZWYuY3VycmVudCk7XG4gIH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxjdWxhdGVPcHRpb25zKCk7XG4gICAgc2V0U2hvdWxkU2hvd0NoaWxkcmVuKGZhbHNlKTtcbiAgfSwgW29wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghaW5zdGFuY2VPcHRpb25zKSByZXR1cm47XG4gICAgKChfYTIgPSBpbnN0YW5jZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnVwZGF0ZU9wdGlvbnMoaW5zdGFuY2VPcHRpb25zKSkgfHwgZ2VuZXJhdGVOZXdJbnN0YW5jZSgpO1xuICB9LCBbaW5zdGFuY2VPcHRpb25zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gKF9hMiA9IGluc3RhbmNlUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZGVzdHJveSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIER5bmFtaWNFbGVtZW50Q29tcG9uZW50LFxuICAgIHtcbiAgICAgIHJlZjogZWxlbWVudFJlZixcbiAgICAgIGFzLFxuICAgICAgY2hpbGRyZW46IHNob3VsZFNob3dDaGlsZHJlbiA/IGNoaWxkcmVuIDogbnVsbCxcbiAgICAgIHN0eWxlOiB7IG9wYWNpdHk6IHNob3VsZFNob3dDaGlsZHJlbiA/IDAgOiAxIH0sXG4gICAgICAuLi5yZW1haW5pbmdQcm9wc1xuICAgIH1cbiAgKTtcbn07XG5leHBvcnQge1xuICBUeXBlSXQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typeit-react/dist/index.es.js\n");

/***/ })

};
;